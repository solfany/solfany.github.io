---
title: "[ERP project] #05. Issues 갑자기 든 의문점 (백과 프론트의 경계선은 어디쯤..?)"
categories:
  - Erp
tags: [ERP project, Issues]
toc_sticky: true
toc_label: "목록"
toc_icon: "bars"
---

## 💡갑자기 든 의문점

백엔드와 프론트 엔드의 경계선은 어디일까 궁금해졌다.
게시판 페이징 기능을 구현하는 와중에 비슷한 기능을 구현하고 있는 동료한테 물어보니 서버에서 페이징 기능을 구현한다고 했고,
나의 경우 클라이언트 쪽에서 구현을 했기 때문에 어떤 차이점이 있는지 명확하게 있는지 프로젝트 도중에 찾아봤던 기억이 난다.

### **백엔드에서의 페이징:**

**장점**:

1. **데이터 전송량 최소화**: 한 번에 필요한 데이터만 클라이언트로 전송하기 때문에 네트워크 트래픽을 절약할 수 있습니다.
2. **서버 자원 효율적 사용**: 대용량의 데이터를 처리할 때, 한 번에 모든 데이터를 메모리에 로드하지 않고 필요한 부분만 쿼리하여 처리하므로 서버의 메모리 사용량을 줄일 수 있습니다.
3. **데이터베이스 최적화**: 데이터베이스에서 제공하는 페이징 기능(예: SQL의 LIMIT, OFFSET)을 사용하여 효율적으로 데이터를 조회할 수 있습니다.

**단점**:

1. **응답 지연**: 사용자가 다음 페이지나 이전 페이지를 요청할 때마다 서버에 요청을 해야 하므로 응답에 지연이 발생할 수 있습니다.

### **프론트엔드에서의 페이징:**

**장점**:

1. **빠른 응답**: 모든 데이터가 이미 클라이언트 측에 로드되어 있기 때문에 페이지간 이동이 빠르고 부드럽습니다.
2. **서버 요청 최소화**: 데이터를 한 번만 가져오고 그 후에는 추가적인 서버 요청이 필요 없으므로 서버 부하를 줄일 수 있습니다.

**단점**:

1. **초기 로딩 지연**: 큰 데이터셋의 경우, 처음에 모든 데이터를 로드하는 데 시간이 걸릴 수 있습니다.
2. **클라이언트 메모리 사용량 증가**: 큰 데이터셋을 한 번에 로드하면 클라이언트의 메모리 사용량이 크게 증가할 수 있습니다.
3. **데이터 신선도 문제**: 초기 로딩 후 데이터가 변경되면 실시간으로 반영되지 않을 수 있습니다.

---

**결론**:

- 대용량의 데이터를 다루는 경우, 백엔드에서의 페이징이 효율적입니다.
- 데이터셋이 작고 사용자 경험에 초점을 둔 경우 프론트엔드에서의 페이징을 고려할 수 있습니다.
- 실시간성이 요구되는 애플리케이션에서는 백엔드 페이징이 적합하며, 캐싱 등의 기법을 함께 사용하여 성능을 최적화할 수 있습니다.

### **백엔드에서 주로 구현해야 할 기능:**

1. **데이터 관리**: 데이터베이스의 CRUD(Create, Read, Update, Delete) 연산은 백엔드에서 처리합니다.
2. **인증 및 권한 관리**: 사용자의 로그인, 로그아웃, 회원가입, 비밀번호 암호화, 토큰 발행 및 검증, 권한 검사 등의 기능은 백엔드에서 처리합니다.
3. **비즈니스 로직**: 사용자의 요청에 따라 데이터를 처리하거나 조작하는 비즈니스 로직은 백엔드에서 구현됩니다.
4. **API 제공**: 클라이언트와의 통신을 위해 API를 제공합니다.
5. **서드파티 통신**: 다른 서비스나 API와의 통신(예: 결제 시스템, 외부 데이터베이스)은 백엔드에서 처리됩니다.
6. **에러 처리**: 데이터베이스 연결 오류, 요청 오류 등의 서버 측 에러를 핸들링합니다.

### **프론트엔드에서 주로 구현해야 할 기능:**

1. **사용자 인터페이스(UI)**: 사용자와의 상호작용을 위한 인터페이스(버튼, 폼, 리스트 등)를 구현합니다.
2. **입력 검증**: 사용자로부터의 입력(예: 폼 입력)을 클라이언트 측에서 먼저 검증합니다. 이는 사용자 경험을 향상시키기 위한 것이며, 보안 검증은 백엔드에서도 이루어져야 합니다.
3. **동적 상호작용**: JavaScript를 사용하여 웹페이지 내에서 동적인 행동(예: 슬라이더, 드롭다운 메뉴 등)을 구현합니다.
4. **데이터 표시**: 백엔드로부터 받은 데이터를 적절한 형식으로 화면에 표시합니다.
5. **클라이언트 측 상태 관리**: 현재 페이지의 상태(예: 로그인 여부, 현재 페이지 번호 등)를 관리합니다.
6. **클라이언트 측 라우팅**: SPA(Single Page Application)의 경우, 페이지 전환 없이 라우팅을 관리합니다.

![image](https://github.com/solfany/solfany.github.io/assets/123814718/d7b0e19e-78ab-47bf-ad96-ee9e08da1c24)

![image](https://github.com/solfany/solfany.github.io/assets/123814718/c59968ff-7b4d-4769-8286-0304f909d197)

<div style="background-color: #d4e4e9; font-size: 0.4rem; border: 1px solid #000; padding: 10px; border-radius: 5px;">
해당 내용에 대해서도 3차 프로젝트 발표 때 ppt 발표를 했었는데 
이번 기회에 정확한 차이점을 알 수 있는 계기가 된 것 같아서 좋다! 문득 문득 이런 의문점을 생길 때 답을 찾아 누군가에게 알려주는 일은 즐거운 일 인 것 같다. 🥹
</div>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}
